"""SqueezeDet model representation.

This module contains the prediction model that will be generated by the
SqueezeDet training.
"""
from typing import List

import cv2                # type: ignore
import easydict           # type: ignore
import numpy as np        # type: ignore
import tensorflow as tf
import time
import sys
import os
import glob

from config import kitti_squeezeDet_config
from train import _draw_box
from nets import *

from lns_common.model import Model, PredictedObject2D, Bounds2D


class SqueezeDetModel(Model):
    """Bounding-box prediction model utilizing SqueezeDet."""

    __model: SqueezeDet
    __config: easydict.EasyDict
    __classes: List[str]
    __logdir: str

    def __init__(self, classes: List[str], logdir: str) -> None:
        """Initialize a SqueezeDet model with the given model and config."""
        with tf.Graph().as_default():
            mc = kitti_squeezeDet_config()
            mc.BATCH_SIZE = 1
            # model parameters will be restored from checkpoint
            mc.LOAD_PRETRAINED_MODEL = False
            model = SqueezeDet(mc, FLAGS.gpu)
            self.__config = mc
            self.__model = model
            self.__classes = classes
            self.__logdir = logdir

    def predict(self, image: np.ndarray) -> List[PredictedObject2D]:
        """Predict the required bounding boxes on the given <image>."""
        # Preprocess the image how squeezedet_keras does it
        with tf.Graph().as_default():
            saver = tf.train.Saver(self.__model.model_params)

            with tf.Session(
                config=tf.ConfigProto(allow_soft_placement=True)
            ) as sess:
                saver.restore(
                    sess, tf.train.latest_checkpoint(self.__logdir)
                )
                image = cv2.resize(
                    image, 
                    (self.__config.IMAGE_WIDTH, self.__config.IMAGE_HEIGHT)
                )
                image = (image - np.mean(image)) / np.std(image)
                image = np.expand_dims(image, axis=0)

                # Detect
                det_boxes, det_probs, det_class = sess.run(
                    [self.__model.det_boxes, self.__model.det_probs, self.__model.det_class],
                    feed_dict={self.__model.image_input:[image]})

                # Filter
                final_boxes, final_probs, final_class = self.__model.filter_prediction(
                    det_boxes[0], det_probs[0], det_class[0])

                keep_idx = [idx for idx in range(len(final_probs)) \
                                if final_probs[idx] > mc.PLOT_PROB_THRESH]
                final_boxes = [final_boxes[idx] for idx in keep_idx]
                final_probs = [final_probs[idx] for idx in keep_idx]
                final_class = [final_class[idx] for idx in keep_idx]

                # Generate the prediction boxes
                predictions = []
                for _box, _class, _score in zip(final_boxes, final_class, final_probs):
                    bounds = Bounds2D(
                        int(_box[0] - (_box[2] / 2)), int(_box[1] - (_box[3] / 2)),
                        int(_box[2]), int(_box[3])
                    )
                    predictions.append(PredictedObject2D(
                        bounds,
                        [self.__classes[_class]],
                        [_score]
                    ))
                return predictions
