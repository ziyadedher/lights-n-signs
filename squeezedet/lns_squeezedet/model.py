"""SqueezeDet model representation.

This module contains the prediction model that will be generated by the
SqueezeDet training.
"""
from typing import List

import cv2                # type: ignore
import easydict           # type: ignore
import numpy as np        # type: ignore
from keras import models  # type: ignore
from squeezedet_keras.model import evaluation  # type: ignore

from lns_common.model import Model, PredictedObject2D, Bounds2D


class SqueezeDetModel(Model):
    """Bounding-box prediction model utilizing SqueezeDet."""

    __model: models.Model
    __config: easydict.EasyDict
    __classes: List[str]

    def __init__(self, model: models.Model, config: easydict.EasyDict,
                 classes: List[str]) -> None:
        """Initialize a SqueezeDet model with the given model and config."""
        self.__model = model
        self.__config = config
        self.__classes = classes

    def predict(self, image: np.ndarray) -> List[PredictedObject2D]:
        """Predict the required bounding boxes on the given <image>."""
        # Store the original width and height before resizing
        width, height, _ = image.shape

        # Preprocess the image how squeezedet_keras does it
        image = cv2.resize(
            image, (self.__config.IMAGE_WIDTH, self.__config.IMAGE_HEIGHT)
        )
        image = (image - np.mean(image)) / np.std(image)
        image = np.expand_dims(image, axis=0)

        # Gather a prediction
        prediction = self.__model.predict(image)

        # Use squeezedet_keras's prediction filtering on batches
        past_batch_size = self.__config.BATCH_SIZE
        self.__config.BATCH_SIZE = 1
        boxes, classes, scores = evaluation.filter_batch(
            prediction, self.__config
        )
        self.__config.BATCH_SIZE = past_batch_size

        # Only one batch
        boxes = boxes[0]
        classes = classes[0]
        scores = scores[0]

        # Resize the bounding boxes back to original size
        boxes[0] *= width / self.__config.IMAGE_WIDTH
        boxes[1] *= height / self.__config.IMAGE_HEIGHT
        boxes[2] *= width / self.__config.IMAGE_WIDTH
        boxes[3] *= height / self.__config.IMAGE_HEIGHT

        # Generate the prediction boxes
        predictions = []
        for _box, _class, _score in zip(boxes, classes, scores):
            bounds = Bounds2D(
                int(_box[0]), int(_box[1]), int(_box[2]), int(_box[3])
            )
            predictions.append(PredictedObject2D(
                bounds,
                [self.__classes[_class]],
                [_score]
            ))
        return predictions
