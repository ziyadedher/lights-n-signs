"""SqueezeDet model representation.

This module contains the prediction model that will be generated by the
SqueezeDet training.
"""
from typing import List

import cv2                # type: ignore
import easydict           # type: ignore
import numpy as np        # type: ignore
import tensorflow as tf
import time
import sys
import os
import glob

from src.config import kitti_squeezeDet_config
from src.train import _draw_box
from src.nets import *

from model_generic import Model, PredictedObject2D, Bounds2D


class SqueezeDetModel(Model):
    """Bounding-box prediction model utilizing SqueezeDet."""

    __classes: List[str]
    __checkpoint: str

    def __init__(self, checkpoint: str, classes: List[str]) -> None:
        """Initialize a SqueezeDet model with the given model and config."""
        self.__classes = classes
        self.__checkpoint = checkpoint

    def predict(self, image: np.ndarray, output_path: str = None, convert = False) -> List[PredictedObject2D]:
        """Predict the required bounding boxes on the given <image>."""
        
        with tf.Graph().as_default():
        
            self.__config = kitti_squeezeDet_config()
            self.__config.BATCH_SIZE = 1
            # model parameters will be restored from checkpoint
            self.__config.LOAD_PRETRAINED_MODEL = False
            self.__config.CLASS_NAMES = tuple(self.__classes)
            self.__model = SqueezeDet(self.__config)

            saver = tf.train.Saver(self.__model.model_params)

            with tf.Session(config=tf.ConfigProto(allow_soft_placement=True)) as sess:

                saver.restore(sess, self.__checkpoint)

                image = cv2.resize(
                    image, 
                    (self.__config.IMAGE_WIDTH, self.__config.IMAGE_HEIGHT)
                )
                img = image - self.__config.BGR_MEANS

                # Detect
                det_boxes, det_probs, det_class = sess.run(
                    [self.__model.det_boxes, self.__model.det_probs, self.__model.det_class],
                    feed_dict={self.__model.image_input:[img]}
                )

                # Filter
                final_boxes, final_probs, final_class = self.__model.filter_prediction(
                    det_boxes[0], det_probs[0], det_class[0])

                keep_idx = [idx for idx in range(len(final_probs)) \
                                if final_probs[idx] > self.__config.PLOT_PROB_THRESH]
                final_boxes = [final_boxes[idx] for idx in keep_idx]
                final_probs = [final_probs[idx] for idx in keep_idx]
                final_class = [final_class[idx] for idx in keep_idx]

                # Generate the prediction boxes
                predictions = []
                for _box, _class, _score in zip(final_boxes, final_class, final_probs):
                    bounds = Bounds2D(
                        int(_box[0] - (_box[2] / 2)), int(_box[1] - (_box[3] / 2)),
                        int(_box[2]), int(_box[3])
                    )
                    predictions.append(PredictedObject2D(
                        bounds,
                        [self.__classes[_class]],
                        [_score]
                    ))
                    
                if output_path:
                    # Draw boxes
                    _draw_box(
                        image, final_boxes,
                        [self.__config.CLASS_NAMES[idx]+': (%.2f)'% prob for idx, prob in zip(final_class, final_probs)]
                    )

                    out_file_name = os.path.join(output_path, 'model_output.png')
                    cv2.imwrite(out_file_name, image)
                    print ('Image detection output saved to {}'.format(out_file_name))
                    
                if convert:
                    new_checkpoint = self.__checkpoint + '_new'
                    saver.save(sess, new_checkpoint)
                    print ("New checkpoint saved to {}".format(new_checkpoint))
                    
                    # Freeze the graph
                    output_node_names = ['conv12/bias_add']
                    frozen_graph_def = tf.graph_util.convert_variables_to_constants(
                        sess,
                        sess.graph_def,
                        output_node_names
                    )

                    # Save the frozen graph
                    with open(os.path.join(os.path.dirname(self.__checkpoint), "output_graph.pb"), 'wb') as f:
                        print("Writing file output_graph.pb")
                        f.write(frozen_graph_def.SerializeToString())
                    
                return predictions
                
                
    def convert(self, sample_image: np.ndarray):
        """Freeze and set the model up for use with the OpenVino framework"""
        
        self.predict(sample_image, convert=True)

