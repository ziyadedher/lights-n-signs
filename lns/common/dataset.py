"""Arbitrary dataset representation.

Contains classes for the tracking of dataset objects through our pipeline
as well as simple utility functions for operation on the datasets.
"""

from typing import Dict, List

import collections
import copy
import os
import struct

from lns.common.structs import Object2D
from lns.common import config

_Images = List[str]
_Classes = List[str]
_Labels = List[Object2D]
_Annotations = Dict[str, _Labels]


class Dataset:
    """Read-only container structure for data generated by preprocessing."""

    Images = List[str]
    Classes = List[str]
    Labels = List[Object2D]
    Annotations = Dict[str, Labels]

    _name: str

    __images: Images
    __classes: Classes
    __annotations: Annotations

    def __init__(self, name: str, images: _Images, classes: _Classes, annotations: _Annotations) -> None:
        """Initialize the data structure.

        <name> is a unique name for this dataset.
        <images> is a list of absolute paths to the images in the dataset.
        <classes> is an indexed list of classes.
        <annotations> is a mapping of image path to a list of 2D objects present in the image.
        """
        self._name = name
        self.__images = copy.deepcopy(images)
        self.__classes = copy.deepcopy(classes)
        self.__annotations = copy.deepcopy(annotations)

    @property
    def name(self) -> str:
        """Get the name of this dataset."""
        return self._name

    @property
    def images(self) -> _Images:
        """Get a list of paths to all images available in the dataset."""
        return copy.deepcopy(self.__images)

    @property
    def classes(self) -> _Classes:
        """Get a mapping of ID to name for all classes in the dataset."""
        return copy.deepcopy(self.__classes)

    @property
    def annotations(self) -> _Annotations:
        """Get all training image annotations.

        Image annotations are structured as a mapping of absolute image path
        (as given in `self.images`) to a list of Object2D.
        """
        return copy.deepcopy(self.__annotations)

    def merge_classes(self, name_postfix: str, mapping: Dict[str, List[str]]) -> 'Dataset':
        """Get a new `Dataset` that has classes merged together.

        Merges the classes under the values in <mapping> under the class given
        by the respective key. Postfixes <name_postfix> to the dataset name to
        get a new name.
        """
        images = self.images
        original_classes = self.classes
        classes = list(set(self.classes) - set(c for l in list(mapping.values()) for c in l) | set(mapping.keys()))
        annotations = self.annotations

        for image in images:
            for detection in annotations[image]:
                # Check if the detection class is in the new classes
                if original_classes[detection.class_index] in classes:
                    detection.class_index = classes.index(original_classes[detection.class_index])
                    continue

                # Change the detection class if required
                for new_class, mapping_classes in mapping.items():
                    if self.classes[detection.class_index] in mapping_classes:
                        detection.class_index = classes.index(new_class)
                        break

        return Dataset(self.name + name_postfix, images, classes, annotations)

    def prune(self):
        """Prune detections which are too small.
        """
        try:
            threshold = config.THRESHOLDS[self.name]
        except KeyError:
            raise Exception("No threshold has been determined for this dataset.")

        dists: Dict[float, Tuple[str, Object2D]] = collections.defaultdict(list)

        images = self.images
        classes = self.classes
        annotations = self.annotations

        for image in images:
            img_area = Dataset._img_area(image)

            for detection in annotations[image]:
                dists[detection.bounds.area / img_area].append((image, detection))

        for dist in sorted(dists.keys()):
            if dist > threshold:
                break
            for image, detection in dists[dist]:
                if detection in annotations[image]:
                    annotations[image].remove(detection)


        return Dataset(self.name, images, classes, annotations)

    @staticmethod
    def _img_area(img_name: str) -> float:
        """Determine dimensions of image stored at absolute path <img_name>."""
        width, height = Dataset._get_image_size(img_name)
        return width * height


    # https://stackoverflow.com/questions/15800704/get-image-size-without-loading-image-into-memory
    # https://raw.githubusercontent.com/scardine/image_size/master/get_image_size.py
    class UnknownImageFormat(Exception):
        """Exception for parsing metadata of image in unknown format."""

    @staticmethod
    def _get_image_size(file_path):
        """Return (width, height) for a given img file content w/ no external dependencies."""
        size = os.path.getsize(file_path)

        with open(file_path, "rb") as input_file:
            height = -1
            width = -1
            data = input_file.read(25)

            if (size >= 10) and data[:6] in ('GIF87a', 'GIF89a'):
                # GIFs
                raw_w, raw_h = struct.unpack("<HH", data[6:10])
                width = int(raw_w)
                height = int(raw_h)
            elif ((size >= 24) and data.startswith(b'\211PNG\r\n\032\n')
                  and (data[12:16] == 'IHDR')):
                # PNGs
                raw_w, raw_h = struct.unpack(">LL", data[16:24])
                width = int(raw_w)
                height = int(raw_h)
            elif (size >= 16) and data.startswith(b'\211PNG\r\n\032\n'):
                # older PNGs?
                raw_w, raw_h = struct.unpack(">LL", data[8:16])
                width = int(raw_w)
                height = int(raw_h)
            elif (size >= 2) and data.startswith(b'\377\330'):
                # JPEG
                width, height = Dataset._process_jpeg(input_file)
            else:
                raise UnknownImageFormat(
                    "Sorry, don't know how to get information from this file."
                )

        return width, height

    @staticmethod
    def _process_jpeg(input_file):
        """Process metadata of JPEG."""
        msg = " raised while trying to decode as JPEG."
        input_file.seek(0)
        input_file.read(2)
        binary = input_file.read(1)
        try:
            while binary and ord(binary) != 0xDA:
                while ord(binary) != 0xFF:
                    binary = input_file.read(1)
                while ord(binary) == 0xFF:
                    binary = input_file.read(1)
                if (ord(binary) >= 0xC0 and ord(binary) <= 0xC3):
                    input_file.read(3)
                    raw_h, raw_w = struct.unpack(">HH", input_file.read(4))
                    break
                else:
                    input_file.read(int(struct.unpack(">H", input_file.read(2))[0]) - 2)
                binary = input_file.read(1)
            width = int(raw_w)
            height = int(raw_h)
        except struct.error:
            raise UnknownImageFormat("StructError" + msg)
        except ValueError:
            raise UnknownImageFormat("ValueError" + msg)
        except Exception as ex:
            raise UnknownImageFormat(ex.__class__.__name__ + msg)

        return width, height


    def __add__(self, other: 'Dataset') -> 'Dataset':
        """Magic method for adding two preprocessing data objects."""
        return Dataset(f"{self.name}-{other.name}",
                       self.images + other.images,
                       list(set(self.classes + other.classes)),
                       {**self.annotations, **other.annotations})

    def __len__(self) -> int:
        """Magic method to get the length of this `Dataset`.

        We define the length of a dataset to the the total number of images.
        """
        return len(self.__images)

    def __eq__(self, other: object) -> bool:
        """Magic method to check if two datasets are equal."""
        if not isinstance(other, Dataset):
            raise NotImplementedError

        return (self.__images == other.images
                and self.__classes == other.classes
                and self.__annotations == other.annotations)
