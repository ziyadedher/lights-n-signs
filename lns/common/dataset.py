"""Arbitrary dataset representation.

Contains classes for the tracking of dataset objects through our pipeline
as well as simple utility functions for operation on the datasets.
"""

import copy
from typing import Dict, List

from lns.common.structs import Object2D

_Images = List[str]
_Classes = List[str]
_Labels = List[Object2D]
_Annotations = Dict[str, _Labels]


class Dataset:
    """Read-only container structure for data generated by preprocessing."""

    Images = List[str]
    Classes = List[str]
    Labels = List[Object2D]
    Annotations = Dict[str, Labels]

    _name: str
    _dynamic: bool

    __images: Images
    __classes: Classes
    __annotations: Annotations

    def __init__(self, name: str, images: _Images, classes: _Classes, annotations: _Annotations, *,
                 dynamic=False) -> None:
        """Initialize the data structure.

        <name> is a unique name for this dataset.
        <images> is a list of absolute paths to the images in the dataset.
        <classes> is an indexed list of classes.
        <annotations> is a mapping of image path to a list of 2D objects present in the image.
        """
        self._name = name
        self._dynamic = dynamic
        self.__images = copy.deepcopy(images)
        self.__classes = copy.deepcopy(classes)
        self.__annotations = copy.deepcopy(annotations)

    @property
    def name(self) -> str:
        """Get the name of this dataset."""
        return self._name

    @property
    def dynamic(self) -> bool:
        """Return whether or not this dataset was dynamically generated."""
        return self._dynamic

    @property
    def images(self) -> _Images:
        """Get a list of paths to all images available in the dataset."""
        return copy.deepcopy(self.__images)

    @property
    def classes(self) -> _Classes:
        """Get a mapping of ID to name for all classes in the dataset."""
        return copy.deepcopy(self.__classes)

    @property
    def annotations(self) -> _Annotations:
        """Get all training image annotations.

        Image annotations are structured as a mapping of absolute image path
        (as given in `self.images`) to a list of Object2D.
        """
        return copy.deepcopy(self.__annotations)

    def merge_classes(self, mapping: Dict[str, List[str]]) -> 'Dataset':
        """Get a new `Dataset` that has classes merged together.

        Merges the classes under the values in <mapping> under the class given
        by the respective key. Postfixes <name_postfix> to the dataset name to
        get a new name.
        """
        images = self.images
        original_classes = self.classes
        classes = list(set(self.classes) - set(c for l in list(mapping.values()) for c in l) | set(mapping.keys()))
        annotations = self.annotations

        for image in images:
            for detection in annotations[image]:
                # Check if the detection class is in the new classes
                if original_classes[detection.class_index] in classes:
                    detection.class_index = classes.index(original_classes[detection.class_index])
                    continue

                # Change the detection class if required
                for new_class, mapping_classes in mapping.items():
                    if self.classes[detection.class_index] in mapping_classes:
                        detection.class_index = classes.index(new_class)
                        break

        return Dataset(self.name, images, classes, annotations, dynamic=True)

    def __add__(self, other: 'Dataset') -> 'Dataset':
        """Magic method for adding two preprocessing data objects."""
        return Dataset(f"{self.name}-{other.name}",
                       self.images + other.images,
                       list(set(self.classes + other.classes)),
                       {**self.annotations, **other.annotations},
                       dynamic=self.dynamic or other.dynamic)

    def __len__(self) -> int:
        """Magic method to get the length of this `Dataset`.

        We define the length of a dataset to the the total number of images.
        """
        return len(self.__images)

    def __eq__(self, other: object) -> bool:
        """Magic method to check if two datasets are equal."""
        if not isinstance(other, Dataset):
            raise NotImplementedError

        return (self.__images == other.images
                and self.__classes == other.classes
                and self.__annotations == other.annotations)
